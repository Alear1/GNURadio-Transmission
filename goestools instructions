Instructions for installing goestools on Ubuntu 20.04 and Raspbian (Same for both)

Instructions from: https://pietern.github.io/goestools/installation.html#installation

First, create a GOES folder somewhere. Then:

:~$ mkdir GOES && cd GOES
:~$ sudo apt-get install -y build-essential cmake git-core libopencv-dev libproj-dev zlib1g-dev
:~$ sudo apt install libairspy-dev librtlsdr-dev
:~$ cd goestools
:~$ mkdir build
:~$ cd build
:~$ cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local
:~$ make
:~$ make install

CONFIGURATION:

goestools is made up of goesrecv for receiving, goeslrit for initial processing and saving, and goesproc for processing.

goesrecv has a bunch of configuration options, controlled by the config file. We'll create a config file using the example
with changes to 'mode' and 'bias-tee':

-cd into the GOES folder
:~$ nano goesrecv.conf
-Copy-paste the following lines into the nano editor (Without the rows of === signs, those are just to show where the file starts and stops):

=====================================================================================
[demodulator]
## Use LRIT mode for GOES-15.
# mode = "lrit"
## Use HRIT mode for GOES-16 or later.
 mode = "hrit"
source = "airspy"

# The section below configures the sample source to use.
#
# You can leave them commented out to use the default values for the
# demodulator mode you choose ("lrit" or "hrit"). To use and configure
# any of them, uncomment the section below, and change the demodulator
# source field to match the source you want to use.
#

 [airspy]
 frequency = 1694100000
##
## By default, goesrecv will use the lowest sample rate available.
## This is 2.5 MSPS for the R2 and 3.0 MSPS for the Mini.
## Because different Airspy models support different sample rates,
## it is recommended to leave the "sample_rate" field commented,
## so that it works for either model.
##
 sample_rate = 3000000
 gain = 18
 bias_tee = true

# [rtlsdr]
# frequency = 1694100000
# sample_rate = 2400000
# gain = 30
# bias_tee = false
# device_index = 0

# [nanomsg]
# sample_rate = 2400000
# connect = "tcp://1.2.3.4:5005"
# receive_buffer = 2097152

[costas]
max_deviation = 200e3

[clock_recovery.sample_publisher]
bind = "tcp://0.0.0.0:5002"
send_buffer = 2097152

[quantization.soft_bit_publisher]
bind = "tcp://0.0.0.0:5001"
send_buffer = 1048576

[decoder.packet_publisher]
bind = "tcp://0.0.0.0:5004"
send_buffer = 1048576

# The demodulator stats publisher sends a JSON object that describes
# the state of the demodulator (gain, frequency correction, samples
# per symbol), for every block of samples.
[demodulator.stats_publisher]
bind = "tcp://0.0.0.0:6001"

# The decoder stats publisher sends a JSON object for every packet it
# decodes (Viterbi corrections, Reed-Solomon corrections, etc.).
[decoder.stats_publisher]
bind = "tcp://0.0.0.0:6002"

# The monitor can log aggregated stats (counters, gauges, and
# histograms) to a statsd daemon. Because this uses UDP, you can keep
=================================================================================================================

We must run goes with a specified config file EVERY TIME.
Use the following command to run goesrecv:

:~$ goesrecv -v -c <ABSOLUTE PATH TO FILE>

We can alter the config file to specify what we want, for now we use the modified example config file above.
Use the vit(avg) column (viterbi error) to determine quality of signal. No signal is about 2000, good signal is between 100 and 200.


